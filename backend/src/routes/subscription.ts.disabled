import { Router } from 'express';
import { auth } from '../middleware/auth';
import { Subscription } from '../models/Subscription';
import { User } from '../models/User';
import { logger } from '../utils/logger';
import { AuthenticatedRequest } from '../types';
import { body, param } from 'express-validator';
import { validationResult } from 'express-validator';

const router = Router();

// @route   GET /api/subscription
// @desc    Get user's current subscription
// @access  Private
router.get('/', auth, async (req: AuthenticatedRequest, res, next) => {
  try {
    const userId = req.user!._id;
    
    let subscription = await Subscription.findOne({ userId });
    
    if (!subscription) {
      // Create default free subscription
      const defaultLimits = Subscription.getDefaultLimits('free');
      subscription = new Subscription({
        userId,
        plan: 'free',
        status: 'active',
        currentPeriodStart: new Date(),
        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
        limits: defaultLimits,
        billing: {
          amount: 0,
          currency: 'USD',
          interval: 'month'
        }
      });
      await subscription.save();
    }

    res.json({
      success: true,
      data: subscription
    });
  } catch (error) {
    logger.error('Error fetching subscription:', error);
    next(error);
  }
});

// @route   GET /api/subscription/plans
// @desc    Get available subscription plans
// @access  Private
router.get('/plans', auth, async (req, res) => {
  try {
    const plans = [
      {
        id: 'free',
        name: 'Free',
        price: 0,
        currency: 'USD',
        interval: 'month',
        features: [
          '10 questions per month',
          '3 video explanations per month',
          'Basic text answers',
          'Standard response time',
          'Limited video quality (720p)'
        ],
        limits: Subscription.getDefaultLimits('free'),
        popular: false,
        buttonText: 'Current Plan'
      },
      {
        id: 'premium',
        name: 'Premium',
        price: 9.99,
        currency: 'USD',
        interval: 'month',
        features: [
          '100 questions per month',
          '25 video explanations per month',
          'Advanced AI explanations',
          'Priority response time',
          'HD video quality (1080p)',
          'Download videos',
          'Share content'
        ],
        limits: Subscription.getDefaultLimits('premium'),
        popular: true,
        buttonText: 'Upgrade to Premium'
      },
      {
        id: 'pro',
        name: 'Pro',
        price: 19.99,
        currency: 'USD',
        interval: 'month',
        features: [
          '500 questions per month',
          '100 video explanations per month',
          'Expert-level AI responses',
          'Instant response time',
          'Premium video quality',
          'Advanced voice options',
          'Priority support',
          'API access'
        ],
        limits: Subscription.getDefaultLimits('pro'),
        popular: false,
        buttonText: 'Upgrade to Pro'
      },
      {
        id: 'enterprise',
        name: 'Enterprise',
        price: 49.99,
        currency: 'USD',
        interval: 'month',
        features: [
          'Unlimited questions',
          'Unlimited video explanations',
          'Custom AI training',
          'White-label solution',
          'Advanced analytics',
          'Custom integrations',
          'Dedicated support',
          'SLA guarantee'
        ],
        limits: Subscription.getDefaultLimits('enterprise'),
        popular: false,
        buttonText: 'Contact Sales'
      }
    ];

    res.json({
      success: true,
      data: plans
    });
  } catch (error) {
    logger.error('Error fetching plans:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching subscription plans'
    });
  }
});

// @route   POST /api/subscription/upgrade
// @desc    Upgrade subscription plan
// @access  Private
router.post('/upgrade', 
  auth,
  [
    body('plan').isIn(['premium', 'pro', 'enterprise']).withMessage('Invalid plan'),
    body('paymentMethodId').optional().isString().withMessage('Invalid payment method')
  ],
  async (req: AuthenticatedRequest, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Validation error',
          errors: errors.array()
        });
      }

      const { plan, paymentMethodId } = req.body;
      const userId = req.user!._id;

      // Get current subscription
      let subscription = await Subscription.findOne({ userId });
      
      if (!subscription) {
        return res.status(404).json({
          success: false,
          message: 'Subscription not found'
        });
      }

      if (subscription.plan === plan) {
        return res.status(400).json({
          success: false,
          message: 'Already subscribed to this plan'
        });
      }

      // TODO: Integrate with Stripe for payment processing
      // For now, we'll simulate the upgrade

      const newLimits = Subscription.getDefaultLimits(plan);
      const planPrices = {
        premium: 9.99,
        pro: 19.99,
        enterprise: 49.99
      };

      // Update subscription
      subscription.plan = plan;
      subscription.limits = newLimits;
      subscription.billing.amount = planPrices[plan as keyof typeof planPrices];
      subscription.currentPeriodStart = new Date();
      subscription.currentPeriodEnd = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
      subscription.status = 'active';

      // Reset usage for new plan
      subscription.usage = {
        questionsThisMonth: 0,
        videosThisMonth: 0,
        tokensUsed: 0,
        lastResetDate: new Date()
      };

      await subscription.save();

      logger.info(`User ${userId} upgraded to ${plan} plan`);

      res.json({
        success: true,
        message: `Successfully upgraded to ${plan} plan`,
        data: subscription
      });
    } catch (error) {
      logger.error('Error upgrading subscription:', error);
      next(error);
    }
  }
);

// @route   POST /api/subscription/cancel
// @desc    Cancel subscription
// @access  Private
router.post('/cancel', auth, async (req: AuthenticatedRequest, res, next) => {
  try {
    const userId = req.user!._id;

    const subscription = await Subscription.findOne({ userId });
    
    if (!subscription) {
      return res.status(404).json({
        success: false,
        message: 'Subscription not found'
      });
    }

    if (subscription.plan === 'free') {
      return res.status(400).json({
        success: false,
        message: 'Cannot cancel free plan'
      });
    }

    // TODO: Cancel Stripe subscription
    
    // Downgrade to free plan at the end of current period
    const freeLimits = Subscription.getDefaultLimits('free');
    
    subscription.status = 'cancelled';
    // Keep current plan until period ends, then it will automatically downgrade
    
    await subscription.save();

    logger.info(`User ${userId} cancelled subscription`);

    res.json({
      success: true,
      message: 'Subscription cancelled successfully. You will continue to have access until the end of your current billing period.',
      data: {
        cancelledAt: new Date(),
        accessUntil: subscription.currentPeriodEnd
      }
    });
  } catch (error) {
    logger.error('Error cancelling subscription:', error);
    next(error);
  }
});

// @route   GET /api/subscription/usage
// @desc    Get detailed usage statistics
// @access  Private
router.get('/usage', auth, async (req: AuthenticatedRequest, res, next) => {
  try {
    const userId = req.user!._id;

    const subscription = await Subscription.findOne({ userId });
    
    if (!subscription) {
      return res.status(404).json({
        success: false,
        message: 'Subscription not found'
      });
    }

    const now = new Date();
    const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
    const daysPassed = now.getDate();
    const progressPercentage = (daysPassed / daysInMonth) * 100;

    const usageStats = {
      plan: subscription.plan,
      status: subscription.status,
      currentPeriod: {
        start: subscription.currentPeriodStart,
        end: subscription.currentPeriodEnd
      },
      usage: {
        questions: {
          used: subscription.usage.questionsThisMonth,
          limit: subscription.limits.questionsPerMonth,
          percentage: subscription.limits.questionsPerMonth > 0 
            ? (subscription.usage.questionsThisMonth / subscription.limits.questionsPerMonth) * 100 
            : 0,
          unlimited: subscription.limits.questionsPerMonth === -1
        },
        videos: {
          used: subscription.usage.videosThisMonth,
          limit: subscription.limits.videosPerMonth,
          percentage: subscription.limits.videosPerMonth > 0 
            ? (subscription.usage.videosThisMonth / subscription.limits.videosPerMonth) * 100 
            : 0,
          unlimited: subscription.limits.videosPerMonth === -1
        },
        tokens: {
          used: subscription.usage.tokensUsed,
          maxPerQuestion: subscription.limits.maxTokensPerQuestion
        }
      },
      features: {
        canShareVideos: subscription.limits.canShareVideos,
        canDownloadVideos: subscription.limits.canDownloadVideos,
        prioritySupport: subscription.limits.prioritySupport,
        maxVideoDuration: subscription.limits.maxVideoDuration
      },
      monthProgress: {
        percentage: progressPercentage,
        daysRemaining: daysInMonth - daysPassed
      }
    };

    res.json({
      success: true,
      data: usageStats
    });
  } catch (error) {
    logger.error('Error fetching usage statistics:', error);
    next(error);
  }
});

// @route   POST /api/subscription/reset-usage
// @desc    Reset monthly usage (admin only or for testing)
// @access  Private
router.post('/reset-usage', auth, async (req: AuthenticatedRequest, res, next) => {
  try {
    const userId = req.user!._id;
    const user = await User.findById(userId);

    // Only allow admins to reset usage (for testing purposes)
    if (user?.role !== 'admin' && process.env.NODE_ENV !== 'development') {
      return res.status(403).json({
        success: false,
        message: 'Access denied'
      });
    }

    const subscription = await Subscription.findOne({ userId });
    
    if (!subscription) {
      return res.status(404).json({
        success: false,
        message: 'Subscription not found'
      });
    }

    subscription.usage = {
      questionsThisMonth: 0,
      videosThisMonth: 0,
      tokensUsed: 0,
      lastResetDate: new Date()
    };

    await subscription.save();

    res.json({
      success: true,
      message: 'Usage statistics reset successfully'
    });
  } catch (error) {
    logger.error('Error resetting usage:', error);
    next(error);
  }
});

// Background job to reset monthly usage
export const resetMonthlyUsage = async () => {
  try {
    const now = new Date();
    const subscriptions = await Subscription.find({
      currentPeriodEnd: { $lte: now },
      status: 'active'
    });

    for (const subscription of subscriptions) {
      // Reset usage
      subscription.usage = {
        questionsThisMonth: 0,
        videosThisMonth: 0,
        tokensUsed: 0,
        lastResetDate: now
      };

      // Update billing period
      subscription.currentPeriodStart = now;
      subscription.currentPeriodEnd = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

      // Handle cancelled subscriptions - downgrade to free
      if (subscription.status === 'cancelled') {
        subscription.plan = 'free';
        subscription.limits = Subscription.getDefaultLimits('free');
        subscription.billing.amount = 0;
        subscription.status = 'active';
      }

      await subscription.save();
    }

    logger.info(`Reset usage for ${subscriptions.length} subscriptions`);
  } catch (error) {
    logger.error('Error resetting monthly usage:', error);
  }
};

export default router;
